"""
This python file aims to check that the simple formula we use for the 
ripple field is accurate.

We work with cartesian coordinates not cylindrical coordinates.

Note that to calculate the full numerical field we use the formula derived in
latex_files/picture_frame_coils_magnetic_field.pdf.
"""
import os
import matplotlib.pyplot as plt
import numpy as np
from python_scripts import my_gfile_reader

def field_vwire(coords,
                z_min=0,
                z_max=1,
                current=1):
    """
    Function to compute the analytical magnetic field
    generated by a vertical wire at the origin.

    Parameters
    ----------
    coords : list
        coords is a list of shape (3,) where each element is the
        coordinates of the wire in the x, y, z directions.
    z_min : float
        Minimum z coordinate of the wire.
    z_max : float
        Maximum z coordinate of the wire.
    current : float
        Current of the wire.

    Returns
    -------
    B : list
        Magnetic field generated by the wire, with shape (3, np.shape(x)).
    """

    def scalar_func(x, y, z):
        """
        Function to compute the scalar component of the magnetic field.
        """
        mu0 = 4*np.pi*1e-7
        r2 = x**2 + y**2
        return 0.25 * mu0 * current / np.pi / r2 * (
            (z_max - z) / np.sqrt(r2 + (z_max - z)**2) + \
            (z - z_min) / np.sqrt(r2 + (z - z_min)**2)
        )

    x = coords[0]
    y = coords[1]
    z = coords[2]
    scalar_component = scalar_func(x, y, z)
    return [-y * scalar_component,
            x * scalar_component,
            x * 0]

def rotate_vector(vector, phi,
                  inverse=False):
    """
    Rotates a vector by 90 degrees about the y-axis,
    then by an angle phi around the z-axis. We use the right-hand rotation
    convention.

    Parameters
    ----------
    vector : list
        Vector to be rotated of shape (3,).
    phi : float
        Angle of rotation.

    Returns
    -------
    vector : list
        Rotated vector of shape (3,).
    """

    if inverse:
        return [-vector[2],
                vector[1] * np.cos(phi) - vector[0] * np.sin(phi),
                vector[0] * np.cos(phi) + vector[1] * np.sin(phi)]
    else:
        return [vector[2] * np.cos(phi) - vector[1] * np.sin(phi),
                vector[1] * np.cos(phi) + vector[2] * np.sin(phi),
                -vector[0]]

def field_coil(coords, phi,
               r_inner=0.5,
               r_outer=8.0,
               height=20,
               current=1e6):
    """
    Function to compute the analytical magnetic field generated by
    a picture-frame coil with the inner leg at R = r_inner and outer leg
    at R = r_outer with z going from -height/2 to height/2 with phi=phi.

    Parameters
    ----------
    coords : list
        coords is a list of shape (3,) where each element is the
        coordinates of the wire in the x, y, z directions.
    r_inner : float
        Inner radius of the coil.
    r_outer : float
        Outer radius of the coil.
    height : float
        Height of the coil.
    phi : float
        Angle of rotation.
    current : float
        Current of the wire.

    Returns
    -------
    B : list
        Magnetic field generated by the wire, with shape (3,).
    """

    def inner_field():
        """
        Function to calculate the magnetic field created by the inner leg of the coil.
        
        Current goes in the positive z-direction.
        """
        coords_inner = [coords[0] - r_inner * np.cos(phi),
                        coords[1] - r_inner * np.sin(phi),
                        coords[2]]
        return field_vwire(coords_inner,
                           z_min=-height/2,
                           z_max=height/2,
                           current=current)

    def outer_field():
        """
        Function to calculate the magnetic field created by the outer leg of the coil.
        
        Current goes in the negative z-direction.
        """
        coords_outer = [coords[0] - r_outer * np.cos(phi),
                        coords[1] - r_outer * np.sin(phi),
                        coords[2]]
        return field_vwire(coords_outer,
                           z_min=-height/2,
                           z_max=height/2,
                           current=-current)

    def upper_field():
        """
        Function to calculate the magnetic field created by the upper part of the
        picture-frame coil.
        
        Current goes in the positive radial direction.
        """
        coords_upper = rotate_vector(coords, phi, inverse=True)
        coords_upper[0] = coords_upper[0] + height/2
        rotated_field = field_vwire(coords_upper,
                                    z_min=r_inner,
                                    z_max=r_outer,
                                    current=current)
        return rotate_vector(rotated_field, phi)

    def lower_field():
        """
        Function to calculate the magnetic field created by the lower part of the
        picture-frame coil.

        Current goes in the negative radial direction.
        """
        coords_lower = rotate_vector(coords, phi, inverse=True)
        coords_lower[0] = coords_lower[0] - height/2
        rotated_field = field_vwire(coords_lower,
                                    z_min=r_inner,
                                    z_max=r_outer,
                                    current=-current)
        return rotate_vector(rotated_field, phi)

    b_coil = [0, 0, 0]
    b_lower = lower_field()
    b_upper = upper_field()
    b_inner = inner_field()
    b_outer = outer_field()
    for i in range(3):
        b_coil[i] = b_lower[i] + b_upper[i] + b_inner[i] + b_outer[i]

    return b_coil

def total_field(coords, num_coils,
                r_inner=0.5,
                r_outer=8.0,
                height=20,
                current=1e6):
    """
    Function to compute the total magnetic field generated by
    a set of picture-frame coils.

    Parameters
    ----------
    coords : list
        coords is a list of shape (3,) where each element is the
        coordinates of the wire in the x, y, z directions.
    num_coils : int
        Number of coils.
    r_inner : float
        Inner radius of the coil.
    r_outer : float
        Outer radius of the coil.
    height : float
        Height of the coil.
    current : float
        Current of the wire.

    Returns
    -------
    b_total : list
        Magnetic field generated by the coils, with shape (3,),
        in cartesian coordinates.
    """

    b_total = [0, 0, 0]
    for i in range(num_coils):
        phi = 2 * np.pi * i / num_coils
        b_coil = field_coil(coords, phi,
                            r_inner=r_inner,
                            r_outer=r_outer,
                            height=height,
                            current=current)
        for j in range(3):
            b_total[j] += + b_coil[j]
    return b_total

def plot_ripple_field(z1=0, z2=5, x_min=1, x_max=7, n_coords=1000,
                      num_coils=16, height=30, current=1e6,
                      r_inner=0.75, r_outer=7.5, r0=4.38):
    """
    Function to plot the ripple field along x at y=0 and 
    z=z1 and z=z2.

    Parameters
    ----------
    z1 : float
        First z coordinate.
    z2 : float
        Second z coordinate.
    x_min : float
        Minimum x coordinate.
    x_max : float
        Maximum x coordinate.
    n_coords : int
        Number of coordinates to plot.

    Returns
    -------
    None
    """

    def interpolate_r(gfile, z):
        r_bnd = gfile.R_bnd[:-1]
        z_bnd = gfile.Z_bnd[:-1]

        if z <= min(z_bnd) or z >= max(z_bnd):
            raise ValueError(f"z value must be within the bounds ({min(z_bnd)}, {max(z_bnd)})")

        intersections = []

        for i, _ in enumerate(z_bnd):
            z1 = z_bnd[i]
            z2 = z_bnd[(i + 1) % len(z_bnd)]
            if z1 <= z <= z2 or z2 <= z <= z1:
                r1 = r_bnd[i]
                r2 = r_bnd[(i + 1) % len(r_bnd)]
                r_interpolated = r1 + (z - z1) * (r2 - r1) / (z2 - z1)
                if r_interpolated not in intersections:
                    intersections.append(r_interpolated)

        if len(intersections) != 2:
            raise ValueError("The line Z=Z should intersect the polygon at exactly two points.")

        return sorted(intersections)


    mu0 = 4*np.pi*1e-7

    line_plot_angle = 0*np.pi / (2 * num_coils)
    r_coords = np.linspace(x_min, x_max, n_coords)
    x_coords = r_coords * np.cos(line_plot_angle)
    y_coords = r_coords * np.sin(line_plot_angle)
    # x_coords = np.linspace(x_min, x_max, n_coords)
    # y_coords = np.zeros_like(x_coords)
    phi_coords = np.arctan2(y_coords, x_coords)
    b_phi0 = 0.5 * mu0 * current * num_coils / np.pi / r_coords
    simple_outer_ripple = b_phi0 * (r_coords / r_outer)**num_coils
    simple_inner_ripple = b_phi0 * (r_inner / r_coords)**num_coils
    combined_simple_ripple = simple_outer_ripple + simple_inner_ripple
    b_phi_norm = 0.5 * mu0 * current * num_coils / np.pi / r0
    repo_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    gfile_path = os.path.join(repo_path, 'input_data', 'SPR-045-16.eqdsk')
    gfile = my_gfile_reader.getGfile(gfile_path)
    r_values = interpolate_r(gfile, 0)

    fig, axs = plt.subplots(1, 2)
    fig_size = fig.get_size_inches()
    fig_size[0] *= 2
    fig.set_size_inches(fig_size)

    for i, z in enumerate([z1, z2]):
        z_coords = z * np.ones_like(x_coords)
        plot_coords = [x_coords, y_coords, z_coords]
        total_b = total_field(plot_coords, num_coils,
                              r_inner=r_inner,
                              r_outer=r_outer,
                              height=height,
                              current=current)
        b_ripple = [total_b[0] + np.sin(phi_coords) * b_phi0,
                    total_b[1] - np.cos(phi_coords) * b_phi0,
                    total_b[2]]
        # b_r_ripple = np.cos(line_plot_angle) * b_ripple[0] + np.sin(line_plot_angle) * b_ripple[1]
        b_phi_ripple = -np.sin(line_plot_angle) * b_ripple[0] + np.cos(line_plot_angle) * b_ripple[1]
        axs[i].plot(r_coords, b_phi_ripple / b_phi_norm,
                    label='Numerical')
        # axs[i].plot(r_coords, np.abs(b_r_ripple) / b_phi_norm,
        #             label='Numerical')
        # axs[i].plot(x_coords, b_ripple[1] / b_phi_norm,
        #             label='Numerical')
        # axs[i].plot(x_coords, simple_outer_ripple / b_phi_norm,
        #             label='Analytic Outer')
        # axs[i].plot(x_coords, simple_inner_ripple / b_phi_norm,
        #             label='Analytic Inner')
        axs[i].plot(r_coords, combined_simple_ripple / b_phi_norm,
                    label='Analytic')
        r_values = interpolate_r(gfile, z)
        for r in r_values:
            axs[i].axvline(r, ls='--', c='k')
        axs[i].set_xlabel('R [m]')
        # axs[i].set_ylabel(r'$B_{y, ripple}$' f'(x, 0, z = {z:.2f} m)'
        #                   r'$/B_{\phi0}$' f'(R = {r0:.2f})')
        # axs[i].set_ylabel(r'$\delta B_\phi^_{ripple}(R, 0, z; N_{coil}=$'
        #                   f'{num_coils}, ' r'$R_\text{inner}=$' f'{r_inner:.2f}, '
        #                   r'$R_\text{outer}=$' f'{r_outer:.2f})$')
        axs[i].set_ylabel(r'$\delta B_\phi^\text{ripple}(R, 0, z) / B_\text{axis}$')
        axs[i].set_title(f'z = {z:.2f} m')
        axs[i].set_yscale('log')
        axs[i].legend()
    print(np.max(b_ripple[2]))

    ylim = axs[0].get_ylim()
    ylim = [1e-8, 1]
    for ax in axs:
        ax.set_ylim(ylim)

    # fig.suptitle('Analytic vs Numerical Ripple along' + '\n'
    #              f'r_inner = {r_inner:.2f} m, r_outer = {r_outer:.2f} m'
    #              f', height = {height:.2f} m',
    #              y=1)
    fig.suptitle('Analytic vs Numerical Ripple',
                 y=0.95)
    plot_path = os.path.join(repo_path, 'plots', 'ripple_check')
    fig.savefig(plot_path + '.png', bbox_inches='tight', dpi=300)
    fig.savefig(plot_path + '.pdf', bbox_inches='tight')

if __name__ == "__main__":

    plot_ripple_field()
